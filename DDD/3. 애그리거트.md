### 3.1 애그리거트

- 객체 모델이 복잡해지면 주요 도메인 요소 간의 관계를 파악하기 어렵다.
- 이는 곧 코드를 변경 및 확장하기 어렵다는 의미이다.
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 관계를 조망할 수 있는 방법이 필요하다.
- 이 방법이 애그리거트이다.

- 애그리거트는 관련된 모델을 하나로 모은 단위이다.
  - 때문에 애그리거트 내부 객체들은 비슷하거나 동일한 라이프 사이클을 갖는다.
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
  - 왜?
- 애그리거트 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.





### 3.2 애그리거트 루트

- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하기 위해 애그리거트 전체를 관리할 주체가 필요하다.
- 이게 애그리거트 루트이다.
- 즉, 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것.
  - 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
  - 즉, 루트가 다양한 애그리거트 정보를 바탕으로 일관된 상황 속에서 도메인 기능을 제공하는 것이다. (다양한 정보를 바탕으로 한 규칙 강제)
- HOW
  - set메서드를 public으로 제공하지 말 것
    - Cancel 등 의도가 더 명확해짐
  - Value 타입을 불변으로 만들 것
- 트랜잭션
  - 범위가 작을 수록 좋다.
  - 한 트랜잭션 안에 여러 테이블 수정이 필요하면 잠금 대상이 많아져 성능을 떨어뜨린다.
  - 한 트랜잭션 안에서는 한 개의 애그리거트 변경을 권장
    - 만약 2개 이상이 피요하다면 응용 서비스에서 수정하도록 구현할 것



### 3.3 리포지터리와 애그리거트

- 개념적으로 한 애그리거트에 한 레포지터리를 가진다.
- 문제 상황: 한 애그리거트에 매핑된 테이블이 2개 이상이라면 애그리거트를 저장할 때 모든 구성요소가 저장되어야 한다.
  - RDBMS는 트랜잭션 활용
  - 몽고 DB는 한 애그리거트를 통째로 한 문서에 저장
- 4장에서 본격적으로 다룬다.



### 3.4 ID를 이용한 애그리거트 참조

- 한 애그리거트가 다른 애그리거트를 필드를 통해 쉽게 참조할 수 있다.
- 하지만 아래와 같은 문제를 야기할 수 있다.
  - 편한 탐색 오용
    - 쉽게 다른 애그리거트의 상태를 변경할 수 있다.
  - 성능에 대한 고민
    - 즉시 로딩 / 지연 로딩
  - 확장 어려움
    - 부하 분산을 위해 도메인 별 다른 DB를 사용할 경우..
- 결론 - 필드 참조보다는 ID를 이용한 참조
  - 애그리거트의 응집도 높이고 
  - ID활용한 방법도 성능에서 문제가 생길 수 있어 조회 전용 쿼리를 사용하는 것이 좋다.



### 3.5 애그리거트 간 집합 연관

- 성능을 고려해 1 - N 연관을 실제 구현에 반영하지 않을 수 있다.
- M-N도 마찬가지로 어떻게 이용될지를 생각해보고 구현을 결정해야 한다.





### 3.6 애그리거트를 팩토리로 사용하기

