### 1. 표현 영역과 응용 영역

- 표현 영역
  - 사용자의 요청을 해석하는 영역
- 응용 영역
  - 실제 사용자가 원하는 기능을 실행하는 영역
- 응용 영역은 표현 영역을 의존하지 않는다. 즉, 사용자와 표현 영역이 어떤 방식으로 소통하는지 알 필요가 없다.





### 2. 응용 서비스의 역할

- 도메인 객체를 사용해서 사용자의 요청을 처리한다.
  - 일반적으로 아래와 같은 과정을 거침
    - 리포지터리에서 애그리거트를 구한다. OR 생성한다.
    - 애그리거트의 도메인 기능을 실행한다. OR 저장한다.
    - 결과를 리턴한다.
- 응용 서비스 로직이 복잡하다면 도메인 로직의 일부를 구현하고 있을 가능성이 높다.
  - 응용 서비스가 간략해지려면 도메인에 로직이 구현되어 있어야 함.
- 트랜잭션도 담당하게 된다.



#### (1) 도메인 로직 넣지 않기

- 도메인 로직을 `도메인 영역`과 `응용 서비스`에 분산해서 구현하면 안 되는 이유?
  1. 코드의 응집성이 떨어진다.
  2. 여러 응용 서비스에 동일한 로직을 구현할 가능성이 높다.
  3. a, b는 모두 코드 변경을 어렵게 만든다.





### 3. 응용 서비스의 구현

#### (1) 응용 서비스의 크기

- 응용 서비스 크기에 대한 고민은 한 Service 클래스가 어떤 범위의 기능을 책임질 것인가에 대한 고민임
- 두 가지 구현 방법이 있다.
  - 한 응용 서비스 클래스에 한 도메인의 모든 기능 구현하기
    - 장점 1) 동일 로직에 대한 코드 중복을 제거할 수 있음
    - 단점 1) 클래스 크기가 커지고 연관성이 적은 코드가 한 클래스에 위치할 수 있음
  - 구분되는 기능 별로 응용 서비스 클래스를 따로 구현하기
    - 위 방식과 반대의 장단점을 가지게 됨
    - 이 방식을 이용하면 동일 로직을 각 서비스 클래스에 중복해서 넣어야 한다는 단점이 있다.
      - 이때 중복해서 사용되는 로직만 Helper클래스로 두어 각 서비스 클래스에서 사용하도록 하여 단점을 보완할 수 있다.



- 필자는 기능 별로 응용 서비스 클래스를 구분하는 방식을 선호한다.





#### (2) 응용 서비스의 인터페이스와 클래스

- 응용 서비스에 인터페이스가 필요한 경우
  - 구현 클래스가 여러 개인 경우
- 현재 구조가 위 경우가 아니라면 인터페이스를 작성할 필요는 없다.
- 단, 표현 영역부터 개발하고 TDD로 진행된다면 인터페이스가 필요할 수 있다.
  - 하지만 이 경우에도 Mokito와 같은 도구를 활용한다면 인터페이스 없이 테스트를 진행할 수 있다.





#### (3) 메서드 파라미터와 값 리턴

- 당연한 이야기이지만 응용 서비스의 파라미터는 사용자가 요구한 기능을 실행하는데 필요한 값들이다.
- 전달 받는 방식은 다양할 수 있다.
  - 개별 파라미터
  - 별도 데이터 클래스 (의미가 더 분명해지려나)
- 응용 서비스의 메서드가 값을 리턴해야 하는 경우는 표현 계층에서 결과를 사용해야하는 경우
  - 주문 번호 return - 주문 번호를 통해 주문 내역 상세 페이지에 접근하기 위해
  - 주문 번호처럼 식별자만 제공할 수도 있지만, 주문 애그리거트를 통으로 리턴할 수도 있다.
    - 하지만 이 방식은 표현 계층에서 도메인 로직을 실행하게 만들어 코드 응집도를 낮추는 원인이 된다.
  - 결국 필요한 값만 리턴하는 것을 추천





#### (4) 표현 영역에 의존하지 않기

- 응용 서비스의 파라미터 타입을 결정할 때 표현 영역과 관련된 타입을 사용하면 안 된다.
  - 응용 서비스 단독 테스트가 어려워짐
  - 표현 영역의 변경이 응용 서비스 영역의 변경으로 이어짐





### 4. 표현 영역

- 표현 영역의 책임
  - 흐름(화면)을 제공 및 제어
  - 사용자 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공
    - 사용자의 요청 데이터를 응용 서비스가 요구하는 형식으로 변환
    - 응용서비스 결과를 사용자에게 응답할 수 있는 형식으로 변환
  - 세션 관리





### 5. 값 검증

- 표현 / 응용에서 모두 수행할 수 있다.
- 원칙적으로는 응용에서 처리한다.
- 응용 서비스에서 값 검증을 진행하고 값 별로 Exception을 발생시키면 여러 값 검증 결과를 한번에 제공하지 못한다. (표현 계층에 누더기 Catch문도 생길 수 있음)
  - ValidationErrorException 이용할 것
- 표현 영역에서 메서드 방식으로 값을 검증하거나 Validator 구현체를 활용해 값을 검증할 수 있다.
- 응용 서비스와 표현 영역이 1:1 관계라면 아래와 같이 검증의 영역을 나누어도 무방
  - 표현 영역 - 필수 값, 값 형식 / 범위
  - 응용 서비스 - 데이터 존재 유무, 논리적 오류 검증



- 필자의 의견
  - 영역을 나누지 말고 응용 서비스에서 모든 검증을 하는 것이 좋다.
    - 코드 작성일 길어지지만
    - 응용서비스의 완성도가 높아짐



### 6. 권한 검사

- 아래 세 영역에서 권한 검사가 이루어질 수 있다.
  - 표현 영역
  - 응용 서비스
  - 도메인
- 권한 검사에 사용될 수 있는 개념들
  - Interceptor / Filter
  - Framework - Spring Security
  - AOP



### 7. 조회 전용 기능과 응용 서비스

- 응용 서비스가 별다른 기능 없이 조회만 수행한다면 응용 서비스 없이 표현 영역에서 DAO/Repository를 사용해도 안될 게 없다.
- 의미 없는 Service 클래스 혹은 메서드를 만들지 않아도 된다.
- 단, 이러한 방식을 선호하지 않는 사람들은 일관된 양식을 중요시하는 것 같다.

