### 1. 애그리거트와 트랜잭션

- DBMS 지원하는 트랜잭션이 아닌 애그리거트를 위한 추가적인 트랜잭션 처리 기법
  - 선점
  - 비선점



### 2. 선점 잠금

- 먼저 애그리거트를 구한 스레드가 작업을 마칠 때까지 다른 스레드는 해당 애그리거트 사용 불가
- 보통 DBMS가 제공하는 행단위 잠금을 사용해 구현한다.
- JPA EntityManager - find(,,LockModeType.PESSIMISTIC_WRITE)
- @Lock(LockModeType.PESSIMISTIC_WRITE)



#### (1) 선점 잠금과 교착상태

- 프로세스 스케줄링 때 배운 교착 상태와 동일.
- 해결책
  - 최대 대기 시간 설정(hint.put() / QueryHints) - DBMS에 따라 지원 여부가 다르다. 확인 필요.



### 3. 비선점 잠금

- 변경 데이터의 DBMS 반영 시점에 변경 가능 여부를 확인하는 방식
- 숫자 타입의 프로퍼티 필요(버전 확인 용)
- @Version
- Exception
  - OptimisticLockingFailureException: 거의 동시에 애그리거트를 수정했다는 의미
  - VersionConflictException: 누군가 애그리거트를 수정했다는 것을 의미



#### (1) 강제 버전 증가

- 루트가 아닌 다른 엔티티 값만 변경된 경우
  - 루트 엔티티의 버전값을 증가시키지 않는다
  - 하지만 논리적으로 해당 애그리거트는 바뀐 것임으로 루트 애그리거트 버전 값을 증가시켜야 한다.
- EntityManager/find(, , LockModeType.OPTIMISTIC_FORCE_INCREMENT)
  - 엔티티를 구할 때 강제로 버전 값을 증가시키는 기능 (트랜잭션 종료 시점에 버전 값 증가 처리)
  - 루트 엔티티가 아닌 경우에도 버전 값 증가

### 4. 오프라인 선점 잠금

- 누군가 수정 화면을 보고 있을 때 다른 사람이 수정 화면 자체를 실행하지 못하게 하려면?
- 해결책은 오프라인 선점 잠금
  - 여러 트랜잭션에 결쳐 동시 변경을 막는다.
  - 트랜잭션 시작과 동시에 오프라인 잠금 선점
  - 마지막 트랜잭션에서 잠금을 해제 - 마지막 트랜잭션에서 잠금을 해제
  - 트랜잭션 중간에 사용자가 멈출 수 있기에 `잠금 유효 시간`이 필요하다.